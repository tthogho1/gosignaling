<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Signaling Test Client</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .container {
      margin-bottom: 20px;
    }

    video {
      width: 400px;
      height: 300px;
      background: #000;
      margin: 10px;
      border: 2px solid #333;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 14px;
      cursor: pointer;
    }

    .videos {
      display: flex;
      flex-wrap: wrap;
    }

    .status {
      padding: 10px;
      margin: 10px 0;
      background: #f0f0f0;
      border-radius: 5px;
    }

    input {
      padding: 8px;
      margin: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>WebRTC Signaling Test Client</h1>

  <div class="container">
    <h2>Connection Settings</h2>
    <label>
      Room ID: <input type="text" id="roomId" value="test-room" />
    </label>
    <button id="joinBtn">Join Room</button>
    <button id="leaveBtn" disabled>Leave</button>
  </div>

  <div class="status" id="status">Not connected</div>

  <div class="container">
    <h2>Video</h2>
    <div class="videos">
      <div>
        <h3>Local</h3>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      <div id="remoteVideos"></div>
    </div>
  </div>

  <script>
    const WS_URL = 'ws://localhost:5000/connect';

    let ws = null;
    let localStream = null;
    let clientId = null;
    let peerConnections = new Map();

    const joinBtn = document.getElementById('joinBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const roomIdInput = document.getElementById('roomId');
    const localVideo = document.getElementById('localVideo');
    const remoteVideos = document.getElementById('remoteVideos');
    const statusDiv = document.getElementById('status');

    const rtcConfig = {
      iceServers: [
        // STUN servers (for public IP address detection for NAT traversal)
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
        // TURN servers (for strict firewall environments)
        // OpenRelay free public TURN server
        {
          urls: 'turn:openrelay.metered.ca:80',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443?transport=tcp',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        }
      ],
      // ICE candidate gathering strategy (all = gather all candidates)
      iceTransportPolicy: 'all',
      // Bundle policy (max-bundle = optimize bandwidth)
      bundlePolicy: 'max-bundle',
      // RTCP multiplexing (require = optimize connection)
      rtcpMuxPolicy: 'require'
    };

    function updateStatus(message) {
      statusDiv.textContent = message;
      console.log(message);
    }

    async function getLocalStream() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 640, height: 480 },
          audio: true
        });
        localVideo.srcObject = localStream;
        updateStatus('Camera and microphone acquired');
      } catch (error) {
        updateStatus('Failed to get media devices: ' + error.message);
        throw error;
      }
    }

    function createPeerConnection(targetClientId) {
      const pc = new RTCPeerConnection(rtcConfig);

      // Add local stream tracks
      localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
      });

      // Receive remote stream
      pc.ontrack = (event) => {
        updateStatus(`Received stream from ${targetClientId}`);
        addRemoteVideo(targetClientId, event.streams[0]);
      };

      // When ICE candidate gathering is complete
      pc.onicecandidate = (event) => {
        if (!event.candidate) {
          console.log('ICE gathering complete for', targetClientId);
        }
      };

      pc.onconnectionstatechange = () => {
        updateStatus(`${targetClientId} connection state: ${pc.connectionState}`);
      };

      peerConnections.set(targetClientId, pc);
      return pc;
    }

    function addRemoteVideo(clientId, stream) {
      let videoContainer = document.getElementById('video-' + clientId);
      if (!videoContainer) {
        videoContainer = document.createElement('div');
        videoContainer.id = 'video-' + clientId;
        videoContainer.innerHTML = `
                    <h3>Peer: ${clientId.substring(0, 8)}</h3>
                    <video id="remote-${clientId}" autoplay playsinline></video>
                `;
        remoteVideos.appendChild(videoContainer);
      }
      const video = document.getElementById('remote-' + clientId);
      video.srcObject = stream;
    }

    function removeRemoteVideo(clientId) {
      const videoContainer = document.getElementById('video-' + clientId);
      if (videoContainer) {
        videoContainer.remove();
      }
    }

    async function handleNewClient(newClientId) {
      updateStatus(`New client joined: ${newClientId}`);
      console.log('[handleNewClient] Starting for client:', newClientId);

      const pc = createPeerConnection(newClientId);

      // Create Offer
      console.log('[handleNewClient] Creating offer...');
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      console.log('[handleNewClient] Offer created');

      // Send immediately without waiting for ICE candidate gathering (Trickle ICE)
      // This speeds up connection establishment
      console.log('[handleNewClient] Sending offer immediately to:', newClientId);
      sendMessage({
        type: 'offer',
        payload: {
          sdp: pc.localDescription.sdp,
          client_id: newClientId
        }
      });
      console.log('[handleNewClient] Offer sent');
    }

    async function handleOffer(senderId, sdp) {
      updateStatus(`Received Offer from ${senderId}`);
      console.log('[handleOffer] Received offer from:', senderId);
      console.log('[handleOffer] SDP:', sdp.substring(0, 100) + '...');

      const pc = createPeerConnection(senderId);

      console.log('[handleOffer] Setting remote description...');
      await pc.setRemoteDescription({
        type: 'offer',
        sdp: sdp
      });

      console.log('[handleOffer] Creating answer...');
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      console.log('[handleOffer] Answer created');

      // Send immediately without waiting for ICE candidate gathering (Trickle ICE)
      console.log('[handleOffer] Sending answer immediately to:', senderId);
      sendMessage({
        type: 'answer',
        payload: {
          sdp: pc.localDescription.sdp,
          client_id: senderId
        }
      });
      console.log('[handleOffer] Answer sent');
    }

    async function handleAnswer(senderId, sdp) {
      updateStatus(`Received Answer from ${senderId}`);
      console.log('[handleAnswer] Received answer from:', senderId);
      console.log('[handleAnswer] SDP:', sdp.substring(0, 100) + '...');

      const pc = peerConnections.get(senderId);
      if (pc) {
        console.log('[handleAnswer] Setting remote description...');
        await pc.setRemoteDescription({
          type: 'answer',
          sdp: sdp
        });
        console.log('[handleAnswer] Remote description set, connection should establish');
      } else {
        console.error('[handleAnswer] Peer connection not found for:', senderId);
      }
    }

    function handleLeaveClient(leavingClientId) {
      updateStatus(`${leavingClientId} has left`);

      const pc = peerConnections.get(leavingClientId);
      if (pc) {
        pc.close();
        peerConnections.delete(leavingClientId);
      }
      removeRemoteVideo(leavingClientId);
    }

    function sendMessage(message) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('[sendMessage] Sending:', message.type, message);
        ws.send(JSON.stringify(message));
      } else {
        console.error('[sendMessage] WebSocket not ready, state:', ws?.readyState);
      }
    }

    async function joinRoom() {
      try {
        await getLocalStream();

        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          updateStatus('WebSocket connection successful');
        };

        ws.onmessage = async (event) => {
          const message = JSON.parse(event.data);
          console.log('Received:', message);

          switch (message.type) {
            case 'notify-client-id':
              // Check if payload is already an object or a string
              const payload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              clientId = payload.client_id;
              updateStatus(`Client ID: ${clientId}`);

              // Join room
              sendMessage({
                type: 'join',
                payload: { room_id: roomIdInput.value }
              });
              break;

            case 'new-client':
              const newClientPayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              await handleNewClient(newClientPayload.client_id);
              break;

            case 'offer':
              const offerPayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              await handleOffer(offerPayload.client_id, offerPayload.sdp);
              break;

            case 'answer':
              const answerPayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              await handleAnswer(answerPayload.client_id, answerPayload.sdp);
              break;

            case 'leave-client':
              const leavePayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              handleLeaveClient(leavePayload.client_id);
              break;

            case 'ping':
              // No ping response needed
              break;

            default:
              console.log('Unknown message type:', message.type);
          }
        };

        ws.onerror = (error) => {
          updateStatus('WebSocket error: ' + error);
        };

        ws.onclose = () => {
          updateStatus('WebSocket connection closed');
          joinBtn.disabled = false;
          leaveBtn.disabled = true;
        };

        joinBtn.disabled = true;
        leaveBtn.disabled = false;

      } catch (error) {
        updateStatus('Error: ' + error.message);
        console.error(error);
      }
    }

    function leaveRoom() {
      if (ws) {
        ws.close();
      }

      peerConnections.forEach(pc => pc.close());
      peerConnections.clear();

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      localVideo.srcObject = null;
      remoteVideos.innerHTML = '';

      updateStatus('Left room');
      joinBtn.disabled = false;
      leaveBtn.disabled = true;
    }

    joinBtn.addEventListener('click', joinRoom);
    leaveBtn.addEventListener('click', leaveRoom);
  </script>
</body>
</html>