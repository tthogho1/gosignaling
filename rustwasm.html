<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Signaling Test Client</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .container {
      margin-bottom: 20px;
    }

    video {
      width: 400px;
      height: 300px;
      background: #000;
      margin: 10px;
      border: 2px solid #333;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 14px;
      cursor: pointer;
    }

    .videos {
      display: flex;
      flex-wrap: wrap;
    }

    .status {
      padding: 10px;
      margin: 10px 0;
      background: #f0f0f0;
      border-radius: 5px;
    }

    input {
      padding: 8px;
      margin: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>WebRTC Signaling Test Client</h1>

  <div class="container">
    <h2>Connection Settings</h2>
    <label>
      Room ID: <input type="text" id="roomId" value="test-room" />
    </label>
    <button id="joinBtn">Join Room</button>
    <button id="leaveBtn" disabled>Leave</button>
  </div>

  <div class="status" id="status">Not connected</div>

  <div class="container">
    <h2>Video</h2>
    <div class="videos">
      <div>
        <h3>Local</h3>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      <div id="remoteVideos"></div>
    </div>
  </div>

  <script type="module">
    import init, { WebRTCClient } from './webrtc-wasm/pkg/webrtc_wasm.js';

    const WS_URL = 'ws://localhost:5000/connect';

    let ws = null;
    let localStream = null;
    let clientId = null;
    let peerConnections = new Map();

    const joinBtn = document.getElementById('joinBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const roomIdInput = document.getElementById('roomId');
    const localVideo = document.getElementById('localVideo');
    const remoteVideos = document.getElementById('remoteVideos');
    const statusDiv = document.getElementById('status');

    const rtcConfig = {
      iceServers: [
        // STUN servers (for public IP address detection for NAT traversal)
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
        // TURN servers (for strict firewall environments)
        // OpenRelay free public TURN server
        {
          urls: 'turn:openrelay.metered.ca:80',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: 'turn:openrelay.metered.ca:443?transport=tcp',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        }
      ],
      // ICE candidate gathering strategy (all = gather all candidates)
      iceTransportPolicy: 'all',
      // Bundle policy (max-bundle = optimize bandwidth)
      bundlePolicy: 'max-bundle',
      // RTCP multiplexing (require = optimize connection)
      rtcpMuxPolicy: 'require'
    };

    function updateStatus(message) {
      statusDiv.textContent = message;
      console.log(message);
    }

    async function getLocalStream() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 640, height: 480 },
          audio: true
        });
        localVideo.srcObject = localStream;
        updateStatus('Camera and microphone acquired');
      } catch (error) {
        updateStatus('Failed to get media devices: ' + error.message);
        throw error;
      }
    }

    function createPeerConnection(targetClientId) {
      const pc = new RTCPeerConnection(rtcConfig);

      // Add local stream tracks
      localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
      });

      // Receive remote stream
      pc.ontrack = (event) => {
        updateStatus(`Received stream from ${targetClientId}`);
        addRemoteVideo(targetClientId, event.streams[0]);
      };

      // When ICE candidate gathering is complete
      pc.onicecandidate = (event) => {
        if (!event.candidate) {
          console.log('ICE gathering complete for', targetClientId);
        }
      };

      pc.onconnectionstatechange = () => {
        updateStatus(`${targetClientId} connection state: ${pc.connectionState}`);
      };

      peerConnections.set(targetClientId, pc);
      return pc;
    }

    function addRemoteVideo(clientId, stream) {
      console.log('[addRemoteVideo] Adding video for:', clientId);
      console.log('[addRemoteVideo] Stream:', stream);
      console.log('[addRemoteVideo] Stream tracks:', stream ? stream.getTracks().length : 'null');

      if (stream) {
        stream.getTracks().forEach(track => {
          console.log('[addRemoteVideo] Track:', track.kind, 'enabled:', track.enabled, 'readyState:', track.readyState);
        });
      }

      let videoContainer = document.getElementById('video-' + clientId);
      if (!videoContainer) {
        videoContainer = document.createElement('div');
        videoContainer.id = 'video-' + clientId;
        videoContainer.innerHTML = `
                    <h3>Peer: ${clientId.substring(0, 8)}</h3>
                    <video id="remote-${clientId}" autoplay playsinline></video>
                `;
        remoteVideos.appendChild(videoContainer);
      }
      const video = document.getElementById('remote-' + clientId);
      console.log('[addRemoteVideo] Video element:', video);

      // Check if stream is already set (avoid setting it multiple times on multiple ontrack events)
      if (video.srcObject && video.srcObject.id === stream.id) {
        console.log('[addRemoteVideo] Stream already set, skipping');
        return;
      }

      // Add event listeners for debugging
      video.onloadedmetadata = () => {
        console.log('[addRemoteVideo] Video metadata loaded');
        console.log('[addRemoteVideo] Video dimensions:', video.videoWidth, 'x', video.videoHeight);
      };
      video.onplay = () => {
        console.log('[addRemoteVideo] Video started playing');
      };
      video.onerror = (e) => {
        console.error('[addRemoteVideo] Video error:', e);
      };

      video.srcObject = stream;
      console.log('[addRemoteVideo] srcObject set successfully');

      // Force play if autoplay doesn't work
      video.play().then(() => {
        console.log('[addRemoteVideo] Video play() successful');
      }).catch(err => {
        console.error('[addRemoteVideo] Video play() failed:', err);
      });
    }

    function removeRemoteVideo(clientId) {
      const videoContainer = document.getElementById('video-' + clientId);
      if (videoContainer) {
        videoContainer.remove();
      }
    }

    async function handleNewClient(newClientId) {
      updateStatus(`New client joined: ${newClientId}`);
      console.log('[handleNewClient] Starting for client:', newClientId);

      const pc = createPeerConnection(newClientId);

      // Create Offer
      console.log('[handleNewClient] Creating offer...');
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      console.log('[handleNewClient] Offer created');

      // Send immediately without waiting for ICE candidate gathering (Trickle ICE)
      // This speeds up connection establishment
      console.log('[handleNewClient] Sending offer immediately to:', newClientId);
      sendMessage({
        type: 'offer',
        payload: {
          sdp: pc.localDescription.sdp,
          client_id: newClientId
        }
      });
      console.log('[handleNewClient] Offer sent');
    }

    async function handleOffer(senderId, sdp) {
      updateStatus(`Received Offer from ${senderId}`);
      console.log('[handleOffer] Received offer from:', senderId);
      console.log('[handleOffer] SDP:', sdp.substring(0, 100) + '...');

      const pc = createPeerConnection(senderId);

      console.log('[handleOffer] Setting remote description...');
      await pc.setRemoteDescription({
        type: 'offer',
        sdp: sdp
      });

      console.log('[handleOffer] Creating answer...');
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      console.log('[handleOffer] Answer created');

      // Send immediately without waiting for ICE candidate gathering (Trickle ICE)
      console.log('[handleOffer] Sending answer immediately to:', senderId);
      sendMessage({
        type: 'answer',
        payload: {
          sdp: pc.localDescription.sdp,
          client_id: senderId
        }
      });
      console.log('[handleOffer] Answer sent');
    }

    async function handleAnswer(senderId, sdp) {
      updateStatus(`Received Answer from ${senderId}`);
      console.log('[handleAnswer] Received answer from:', senderId);
      console.log('[handleAnswer] SDP:', sdp.substring(0, 100) + '...');

      const pc = peerConnections.get(senderId);
      if (pc) {
        console.log('[handleAnswer] Setting remote description...');
        await pc.setRemoteDescription({
          type: 'answer',
          sdp: sdp
        });
        console.log('[handleAnswer] Remote description set, connection should establish');
      } else {
        console.error('[handleAnswer] Peer connection not found for:', senderId);
      }
    }

    function handleLeaveClient(leavingClientId) {
      updateStatus(`${leavingClientId} has left`);

      const pc = peerConnections.get(leavingClientId);
      if (pc) {
        pc.close();
        peerConnections.delete(leavingClientId);
      }
      removeRemoteVideo(leavingClientId);
    }

    function sendMessage(message) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('[sendMessage] Sending:', message.type, message);
        ws.send(JSON.stringify(message));
      } else {
        console.error('[sendMessage] WebSocket not ready, state:', ws?.readyState);
      }
    }

    let wasmClient = null;
    let wasmMessageQueue = [];

    async function joinRoom() {
      try {
        // Initialize WASM
        console.log('[WASM] Initializing...');
        await init();

        wasmClient = new WebRTCClient();
        console.log('[WASM] Client created');

        // Setup callbacks
        wasmClient.setOnStatusChange((message) => {
          updateStatus(message);
        });

        wasmClient.setOnRemoteStream((clientId, stream) => {
          console.log('[WASM] Remote stream received for:', clientId);
          addRemoteVideo(clientId, stream);
        });

        wasmClient.setOnIceCandidate((candidateMessage) => {
          console.log('[WASM] Sending ICE candidate via WebSocket');
          ws.send(candidateMessage);
        });

        // Get local stream
        console.log('[WASM] Getting local stream...');
        localStream = await wasmClient.getLocalStream();
        localVideo.srcObject = localStream;
        console.log('[WASM] Local stream set');

        // Connect WebSocket (note: actual message handling still needs JS bridge)
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          updateStatus('WebSocket connection successful');
        };

        ws.onmessage = async (event) => {
          const message = JSON.parse(event.data);
          console.log('Received:', message);

          switch (message.type) {
            case 'notify-client-id':
              // Check if payload is already an object or a string
              const payload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              clientId = payload.client_id;
              updateStatus(`Client ID: ${clientId}`);

              // Join room
              sendMessage({
                type: 'join',
                payload: { room_id: roomIdInput.value }
              });
              break;

            case 'new-client':
              const newClientPayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              console.log('[WASM] Handling new client:', newClientPayload.client_id);
              if (wasmClient) {
                try {
                  const offerMessage = await wasmClient.handleNewClient(newClientPayload.client_id);
                  console.log('[WASM] Received offer message type:', typeof offerMessage);
                  console.log('[WASM] Offer message value:', offerMessage);
                  if (offerMessage) {
                    console.log('[WASM] Sending offer via WebSocket');
                    ws.send(offerMessage);
                  }
                } catch (error) {
                  console.error('[WASM] Error handling new client:', error);
                }
              } else {
                await handleNewClient(newClientPayload.client_id);
              }
              break;

            case 'offer':
              const offerPayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              console.log('[WASM] Handling offer from:', offerPayload.client_id);
              if (wasmClient) {
                try {
                  const answerMessage = await wasmClient.handleOffer(offerPayload.client_id, offerPayload.sdp);
                  if (answerMessage) {
                    console.log('[WASM] Sending answer via WebSocket');
                    ws.send(answerMessage);
                  }
                } catch (error) {
                  console.error('[WASM] Error handling offer:', error);
                }
              } else {
                await handleOffer(offerPayload.client_id, offerPayload.sdp);
              }
              break;

            case 'answer':
              const answerPayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              console.log('[WASM] Handling answer from:', answerPayload.client_id);
              if (wasmClient) {
                try {
                  await wasmClient.handleAnswer(answerPayload.client_id, answerPayload.sdp);
                } catch (error) {
                  console.error('[WASM] Error handling answer:', error);
                }
              } else {
                await handleAnswer(answerPayload.client_id, answerPayload.sdp);
              }
              break;

            case 'ice-candidate':
              const iceCandidatePayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              console.log('[WASM] Handling ICE candidate from:', iceCandidatePayload.client_id);
              if (wasmClient) {
                try {
                  await wasmClient.handleIceCandidate(
                    iceCandidatePayload.client_id,
                    iceCandidatePayload.candidate,
                    iceCandidatePayload.sdpMid || null,
                    iceCandidatePayload.sdpMLineIndex !== undefined ? iceCandidatePayload.sdpMLineIndex : null
                  );
                } catch (error) {
                  console.error('[WASM] Error handling ICE candidate:', error);
                }
              }
              break;

            case 'leave-client':
              const leavePayload = typeof message.payload === 'string'
                ? JSON.parse(message.payload)
                : message.payload;
              if (wasmClient) {
                wasmClient.handleLeaveClient(leavePayload.client_id);
              } else {
                handleLeaveClient(leavePayload.client_id);
              }
              break;

            case 'ping':
              // No ping response needed
              break;

            default:
              console.log('Unknown message type:', message.type);
          }
        };

        ws.onerror = (error) => {
          updateStatus('WebSocket error: ' + error);
        };

        ws.onclose = () => {
          updateStatus('WebSocket connection closed');
          joinBtn.disabled = false;
          leaveBtn.disabled = true;
        };

        joinBtn.disabled = true;
        leaveBtn.disabled = false;

      } catch (error) {
        updateStatus('Error: ' + error.message);
        console.error(error);
      }
    }

    function leaveRoom() {
      if (wasmClient) {
        wasmClient.close();
        wasmClient = null;
      } else {
        if (ws) {
          ws.close();
        }

        peerConnections.forEach(pc => pc.close());
        peerConnections.clear();

        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }
      }

      localVideo.srcObject = null;
      remoteVideos.innerHTML = '';

      updateStatus('Left room');
      joinBtn.disabled = false;
      leaveBtn.disabled = true;
    }

    joinBtn.addEventListener('click', joinRoom);
    leaveBtn.addEventListener('click', leaveRoom);
  </script>
</body>
</html>